name: Deploy Mortgage Demo to Azure

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      # Container registry connection information
      # Note: AZURE_CONTAINER_REGISTRY_USERNAME and AZURE_CONTAINER_REGISTRY_PASSWORD are only needed for pushing images 
      # Container apps now pull images using system-assigned managed identities
      AZURE_CONTAINER_REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
      AZURE_CONTAINER_REGISTRY_USERNAME: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
      AZURE_CONTAINER_REGISTRY_PASSWORD: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}
      AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
      RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      LOCATION: ${{ vars.AZURE_LOCATION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4      
      
      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          
      # Ensure container app environment is properly deleted before deployment
      - name: Verify Container App Environment is Clean
        run: |
          echo "Checking for existing container app environment..."
          
          # Check if environment exists
          env_exists=$(az containerapp env list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?name=='mortgageapp-env'].id" -o tsv)
          
          if [ -n "$env_exists" ]; then
            echo "Container app environment 'mortgageapp-env' exists. Checking if any container apps are using it..."
            
            # Check for any container apps using this environment
            apps_using_env=$(az containerapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?properties.managedEnvironmentId=='$env_exists'].name" -o tsv)
            
            if [ -n "$apps_using_env" ]; then
              echo "Found container apps using this environment. Deleting them first..."
              for app in $apps_using_env; do
                echo "Deleting container app '$app'..."
                az containerapp delete --name $app --resource-group ${{ env.RESOURCE_GROUP }} --yes
              done
              
              echo "Waiting 30 seconds for resources to be released..."
              sleep 30
            fi
            
            echo "Deleting container app environment..."
            az containerapp env delete --name mortgageapp-env --resource-group ${{ env.RESOURCE_GROUP }} --yes
            
            echo "Waiting 60 seconds for resources to be fully released..."
            sleep 60
            
            # Verify environment is deleted
            env_still_exists=$(az containerapp env list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?name=='mortgageapp-env'].id" -o tsv)
            if [ -n "$env_still_exists" ]; then
              echo "Warning: Container app environment still exists after deletion attempt. This may cause deployment issues."
            else
              echo "Container app environment successfully deleted."
            fi
          else
            echo "No existing container app environment found. Clean state for deployment."
          fi

      # Create managed identity early to ensure it exists before container app deployment
      - name: Create Managed Identity
        id: create_managed_identity
        run: |
          # Check if identity exists
          existing_identity=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'id' -o tsv 2>/dev/null) || true
          
          if [ -z "$existing_identity" ]; then
            echo "Creating managed identity mortgageapp-identity"
            az identity create --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --location ${{ env.LOCATION }}
          else
            echo "Managed identity mortgageapp-identity already exists"
          fi
            
          # Get the principal ID
          principal_id=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'principalId' -o tsv)
          client_id=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'clientId' -o tsv)
          resource_id=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'id' -o tsv)
          
          echo "principal_id=$principal_id" >> $GITHUB_OUTPUT
          echo "client_id=$client_id" >> $GITHUB_OUTPUT
          echo "resource_id=$resource_id" >> $GITHUB_OUTPUT
          
      # Assign AcrPull role to managed identity
      - name: Assign AcrPull role to Managed Identity
        run: |
          # Extract ACR name from the registry URL
          full_registry_url="${{ env.AZURE_CONTAINER_REGISTRY }}"
          if [[ $full_registry_url == *.azurecr.io ]]; then
            acr_name=$(echo "$full_registry_url" | sed -E 's/([^.]+).azurecr.io/\1/')
            echo "Extracted ACR name: $acr_name"
            
            # Get ACR resource ID
            acr_id=$(az acr show --name "$acr_name" --query id -o tsv 2>/dev/null || echo "")
            
            if [ -n "$acr_id" ]; then
              echo "ACR resource ID: $acr_id"
              
              # Check if role assignment exists
              existing_acr_role=$(az role assignment list --assignee "${{ steps.create_managed_identity.outputs.principal_id }}" --role "AcrPull" --scope "$acr_id" --query "[].roleDefinitionName" -o tsv)
              
              if [ -z "$existing_acr_role" ]; then
                echo "Granting AcrPull role to managed identity on ACR"
                az role assignment create --assignee "${{ steps.create_managed_identity.outputs.principal_id }}" --role "AcrPull" --scope "$acr_id"
                
                # Verify the role was assigned
                verify_acr_role=$(az role assignment list --assignee "${{ steps.create_managed_identity.outputs.principal_id }}" --role "AcrPull" --scope "$acr_id" --query "[].roleDefinitionName" -o tsv)
                if [ -z "$verify_acr_role" ]; then
                  echo "Warning: Failed to assign AcrPull role to managed identity"
                fi
              else
                echo "Managed identity already has AcrPull role on ACR"
              fi
            else
              echo "Warning: Could not retrieve ACR resource ID"
            fi
          else
            echo "Warning: Could not parse ACR name from URL"
          fi

      # Grant SQL Administrator role to the service principal at resource group level
      - name: Grant SQL Administrator role to service principal
        run: |
          # Add error handling to ensure the script fails if critical commands fail
          set -e
          
          # Get the object ID of the current service principal
          echo "Getting service principal ID..."
          current_sp_id=$(az ad signed-in-user show --query id -o tsv 2>/dev/null || az ad sp show --id $(az account show --query user.name -o tsv) --query id -o tsv)
          
          if [ -z "$current_sp_id" ]; then
            echo "Error: Failed to obtain service principal ID"
            exit 1
          fi
          
          echo "Service principal ID: $current_sp_id"
            # Check if role assignment exists to avoid duplicate assignments
          echo "Checking for existing role assignment..."
          # Get resource group ID for proper scoping
          rg_id=$(az group show --name ${{ env.RESOURCE_GROUP }} --query id -o tsv)
          existing_role=$(az role assignment list --assignee "$current_sp_id" --role "SQL Server Contributor" --scope "$rg_id" --query "[].roleDefinitionName" -o tsv)
            if [ -z "$existing_role" ]; then
            echo "Granting SQL Server Contributor role to service principal at resource group level"
            # Get resource group ID for proper scoping
            rg_id=$(az group show --name ${{ env.RESOURCE_GROUP }} --query id -o tsv)
            az role assignment create --assignee "$current_sp_id" --role "SQL Server Contributor" --scope "$rg_id"
              # Verify the role was assigned
            verify_role=$(az role assignment list --assignee "$current_sp_id" --role "SQL Server Contributor" --scope "$rg_id" --query "[].roleDefinitionName" -o tsv)
            if [ -z "$verify_role" ]; then
              echo "Error: Failed to assign SQL Server Contributor role"
              exit 1
            fi
          else
            echo "Service principal already has SQL Server Contributor role"
          fi          # Grant the service principal AcrPull role on the Azure Container Registry
          echo "Setting up role assignment for ACR access..."
          
          # Extract ACR name more reliably from the full registry URL
          full_registry_url="${{ env.AZURE_CONTAINER_REGISTRY }}"
          # First check if this is a custom domain or the default azurecr.io domain
          if [[ $full_registry_url == *.azurecr.io ]]; then
            # For azurecr.io domain, extract just the registry name
            acr_name=$(echo "$full_registry_url" | sed -E 's/([^.]+).azurecr.io/\1/')
            echo "Extracted ACR name from azurecr.io domain: $acr_name"
          else
            # For custom domain, we need to find the registry via its login server
            echo "Custom domain detected, looking up ACR by login server..."
            # List all ACRs and find the one with matching login server
            acr_name=$(az acr list --query "[?loginServer=='$full_registry_url'].name" -o tsv)
            if [ -z "$acr_name" ]; then
              echo "Error: Could not find ACR with login server $full_registry_url"
              # Continue anyway, as this is just for additional permissions and not critical
              echo "Continuing deployment without ACR role assignment"
              acr_id=""
            else
              echo "Found ACR name: $acr_name"
            fi
          fi
          
          # Only try to get resource ID if we have an ACR name
          if [ -n "$acr_name" ]; then
            echo "Getting resource ID for ACR: $acr_name"
            acr_id=$(az acr show --name "$acr_name" --query id -o tsv 2>/dev/null || echo "")
            
            if [ -z "$acr_id" ]; then
              echo "Warning: Failed to get ACR resource ID. ACR may be in a different subscription or resource group."
              # Continue anyway, as this is just for additional permissions and not critical
              echo "Continuing deployment without ACR role assignment"
            fi
          else
            acr_id=""
          fi
            # Only proceed with role assignment if we found the ACR resource ID
          if [ -n "$acr_id" ]; then
            echo "ACR resource ID: $acr_id"
            
            # Check if role assignment exists
            existing_acr_role=$(az role assignment list --assignee "$current_sp_id" --role "AcrPull" --scope "$acr_id" --query "[].roleDefinitionName" -o tsv)
            
            if [ -z "$existing_acr_role" ]; then
              echo "Granting AcrPull role to service principal on ACR"
              az role assignment create --assignee "$current_sp_id" --role "AcrPull" --scope "$acr_id"
              
              # Verify the role was assigned
              verify_acr_role=$(az role assignment list --assignee "$current_sp_id" --role "AcrPull" --scope "$acr_id" --query "[].roleDefinitionName" -o tsv)
              if [ -z "$verify_acr_role" ]; then
                echo "Warning: Failed to assign AcrPull role"
                # Continue anyway, as this is just for additional permissions and not critical
                echo "Continuing deployment without ACR role assignment"
              fi
            else
              echo "Service principal already has AcrPull role on ACR"
            fi
          else
            echo "Skipping ACR role assignment since ACR resource ID was not found"
          fi

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v2
        with:
          login-server: ${{ env.AZURE_CONTAINER_REGISTRY }}
          username: ${{ env.AZURE_CONTAINER_REGISTRY_USERNAME }}
          password: ${{ env.AZURE_CONTAINER_REGISTRY_PASSWORD }}

      - name: Build and push Loan Processing Service (.NET)
        run: |
          cd loan-processing-service
          dotnet publish -c Release -o out
          docker build -t ${{ env.AZURE_CONTAINER_REGISTRY }}/loan-processing-service:${{ github.sha }} .
          docker push ${{ env.AZURE_CONTAINER_REGISTRY }}/loan-processing-service:${{ github.sha }}

      - name: Build and push Customer Service (Java)
        run: |
          cd customer-service
          ./mvnw package -DskipTests || mvn package -DskipTests
          docker build -t ${{ env.AZURE_CONTAINER_REGISTRY }}/customer-service:${{ github.sha }} .
          docker push ${{ env.AZURE_CONTAINER_REGISTRY }}/customer-service:${{ github.sha }}

      - name: Build and push Web UI (React)
        run: |
          cd web-ui
          npm install
          npm run build
          docker build -t ${{ env.AZURE_CONTAINER_REGISTRY }}/web-ui:${{ github.sha }} .
          docker push ${{ env.AZURE_CONTAINER_REGISTRY }}/web-ui:${{ github.sha }}
          
      # Removed pre-Bicep AAD-only check since we will handle this after getting actual SQL server name from Bicep outputs      # Get current user/service principal ID for SQL AD Admin
      - name: Get current user object ID for AD Admin
        id: get_current_user
        run: |
          # Get the object ID of the current user (service principal)
          current_user_id=$(az ad signed-in-user show --query id -o tsv 2>/dev/null || az ad sp show --id $(az account show --query user.name -o tsv) --query id -o tsv)
          echo "object_id=$current_user_id" >> $GITHUB_OUTPUT
            # Check and clean up existing container apps before deployment
      - name: Check and clean up existing container apps
        run: |
          # Set up error handling
          set -e
          
          echo "Checking for existing container apps in resource group ${{ env.RESOURCE_GROUP }}..."
          
          # Loop through all container apps we want to deploy
          for app in loan-processing-service customer-service web-ui; do
            echo "Checking if container app '$app' exists..."
            
            # Check if app exists (doesn't matter in which environment)
            app_exists=$(az containerapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?name=='$app'].id" -o tsv)
            
            if [ -n "$app_exists" ]; then
              echo "Container app '$app' found. Getting current environment..."
              
              # Get the environment ID from the container app
              current_env_id=$(az containerapp show --name $app --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.managedEnvironmentId" -o tsv)
              current_env_name=$(echo $current_env_id | awk -F'/' '{print $NF}')
                # Get the revision ID to check status before deleting
              echo "Getting revisions for container app '$app'..."
              revisions=$(az containerapp revision list --name $app --resource-group ${{ env.RESOURCE_GROUP }} --query "[].name" -o tsv)
              
              # Only try to get logs if revisions exist
              if [ -n "$revisions" ]; then
                echo "Found revisions: $revisions"
                echo "Getting logs for container app '$app'..."
                az containerapp logs show --name $app --resource-group ${{ env.RESOURCE_GROUP }} --tail 100 || echo "Could not retrieve logs, continuing..."
              else
                echo "No revisions found for container app '$app', skipping logs"
              fi
              
              echo "Container app '$app' exists in environment '$current_env_name'. Deleting container app..."
              
              # Delete the container app with increased timeout
              az containerapp delete --name $app --resource-group ${{ env.RESOURCE_GROUP }} --yes --debug
              
              # Wait a moment for resources to be fully released
              echo "Waiting 30 seconds for resources to be released..."
              sleep 30
              
              echo "Container app '$app' deleted successfully."
            else
              echo "Container app '$app' not found. No cleanup needed."
            fi
          done
          
          # Check container app environment status
          echo "Checking container app environment status..."
          env_exists=$(az containerapp env list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?name=='mortgageapp-env'].id" -o tsv)
          if [ -n "$env_exists" ]; then
            echo "Container app environment found. Getting status..."
            env_status=$(az containerapp env show --name mortgageapp-env --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.provisioningState" -o tsv)
            echo "Container app environment status: $env_status"
            
            # If environment is in a failed state, delete it
            if [[ "$env_status" == "Failed" ]]; then
              echo "Container app environment is in Failed state. Checking if any container apps still exist..."
              
              remaining_apps=$(az containerapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[].name" -o tsv)
              if [ -n "$remaining_apps" ]; then
                echo "Some container apps still exist. Deleting them first..."
                for app in $remaining_apps; do
                  echo "Deleting container app '$app'..."
                  az containerapp delete --name $app --resource-group ${{ env.RESOURCE_GROUP }} --yes
                done
                
                echo "Waiting 30 seconds for resources to be released..."
                sleep 30
              fi
              
              echo "Deleting failed container app environment..."
              az containerapp env delete --name mortgageapp-env --resource-group ${{ env.RESOURCE_GROUP }} --yes
              
              echo "Waiting 60 seconds for resources to be fully released..."
              sleep 60
            fi
          fi
          
          echo "Container app cleanup completed."
          
      - name: Deploy infrastructure and container apps (Bicep)
        id: deploy_bicep
        run: |
          DEPLOYMENT_NAME=mortgage-deployment-${{ github.sha }}
          
          # Check if managed identity exists before deployment
          echo "Verifying managed identity 'mortgageapp-identity' exists..."
          identity_exists=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'id' -o tsv 2>/dev/null || echo "")
          if [ -z "$identity_exists" ]; then
            echo "Warning: Managed identity 'mortgageapp-identity' does not exist. Creating it now..."
            az identity create --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --location ${{ env.LOCATION }}
          else
            echo "Managed identity 'mortgageapp-identity' exists: $identity_exists"
          fi
          
          # First run a what-if operation to check for potential issues
          echo "Running what-if deployment validation..."
          
          # Extract ACR name from the registry URL for what-if
          full_registry_url="${{ env.AZURE_CONTAINER_REGISTRY }}"
          acr_in_same_rg="false"
          if [[ $full_registry_url == *.azurecr.io ]]; then
            acr_name=$(echo "$full_registry_url" | sed -E 's/([^.]+).azurecr.io/\1/')
            acr_exists=$(az acr list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?name=='$acr_name'].id" -o tsv)
            if [ -n "$acr_exists" ]; then
              acr_in_same_rg="true"
            fi
          fi
          
          # Verify container registry and check permissions
          echo "Verifying container registry permissions and network rules..."
          if [[ -n "$acr_name" ]]; then
            echo "Checking ACR $acr_name network rules..."
            acr_network=$(az acr show --name "$acr_name" --query 'networkRuleSet.defaultAction' -o tsv 2>/dev/null || echo "")
            echo "ACR network default action: $acr_network"
            
            # Check if managed identity has ACR Pull role
            identity_principal_id=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'principalId' -o tsv)
            acr_id=$(az acr show --name "$acr_name" --query id -o tsv 2>/dev/null || echo "")
            if [[ -n "$acr_id" && -n "$identity_principal_id" ]]; then
              echo "Checking if managed identity has AcrPull role on ACR..."
              role_assignments=$(az role assignment list --assignee "$identity_principal_id" --scope "$acr_id" --query "[?roleDefinitionName=='AcrPull'].roleDefinitionName" -o tsv)
              if [ -z "$role_assignments" ]; then
                echo "Managed identity does not have AcrPull role on ACR. Adding role assignment..."
                az role assignment create --assignee "$identity_principal_id" --role "AcrPull" --scope "$acr_id"
              else
                echo "Managed identity already has AcrPull role on ACR."
              fi
            fi
          fi
          
          echo "Running what-if deployment..."
          az deployment group what-if \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --template-file infra/main.bicep \
            --parameters \
              azureAdAdminObjectId=${{ steps.get_current_user.outputs.object_id }} \
              loanProcessingImage=${{ env.AZURE_CONTAINER_REGISTRY }}/loan-processing-service:${{ github.sha }} \
              customerServiceImage=${{ env.AZURE_CONTAINER_REGISTRY }}/customer-service:${{ github.sha }} \
              webUiImage=${{ env.AZURE_CONTAINER_REGISTRY }}/web-ui:${{ github.sha }} \
              assignAcrRoles=$acr_in_same_rg \
              registryServer=${{ env.AZURE_CONTAINER_REGISTRY }}
          
          # Now run the actual deployment with increased timeout and debugging
          echo "Running actual deployment..."
          
          # Check if ACR is in same resource group to determine if we should try to assign roles
          acr_in_same_rg="false"
          
          # Extract ACR name from the registry URL
          full_registry_url="${{ env.AZURE_CONTAINER_REGISTRY }}"
          if [[ $full_registry_url == *.azurecr.io ]]; then
            acr_name=$(echo "$full_registry_url" | sed -E 's/([^.]+).azurecr.io/\1/')
            echo "Checking if ACR '$acr_name' exists in resource group ${{ env.RESOURCE_GROUP }}..."
            acr_exists=$(az acr list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?name=='$acr_name'].id" -o tsv)
            if [ -n "$acr_exists" ]; then
              echo "ACR exists in same resource group, will assign roles"
              acr_in_same_rg="true"
            fi
          fi
          
          # Deploy with debug logging enabled
          az config set core.collect_telemetry=yes
          az config set extension.use_dynamic_install=yes_without_prompt
          
          echo "Starting Bicep deployment with verbose logging..."
          az deployment group create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --template-file infra/main.bicep \
            --parameters \
              azureAdAdminObjectId=${{ steps.get_current_user.outputs.object_id }} \
              loanProcessingImage=${{ env.AZURE_CONTAINER_REGISTRY }}/loan-processing-service:${{ github.sha }} \
              customerServiceImage=${{ env.AZURE_CONTAINER_REGISTRY }}/customer-service:${{ github.sha }} \
              webUiImage=${{ env.AZURE_CONTAINER_REGISTRY }}/web-ui:${{ github.sha }} \
              assignAcrRoles=$acr_in_same_rg \
              registryServer=${{ env.AZURE_CONTAINER_REGISTRY }} \
            --            name $DEPLOYMENT_NAME \
            --verbose \
            --debug \
            --no-wait

          echo "Deployment started in background. Will monitor status..."
          
          # Poll for deployment completion
          TIMEOUT_SECONDS=900  # 15 minutes timeout
          POLL_INTERVAL=30     # Check every 30 seconds
          START_TIME=$(date +%s)
          CURRENT_TIME=$(date +%s)
          
          while [ $((CURRENT_TIME - START_TIME)) -lt $TIMEOUT_SECONDS ]; do
            echo "Checking deployment status at $(date)..."
            DEPLOYMENT_STATUS=$(az deployment group show \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --name $DEPLOYMENT_NAME \
              --query "properties.provisioningState" -o tsv)
              
            echo "Current status: $DEPLOYMENT_STATUS"
            
            # Check if deployment completed
            if [[ "$DEPLOYMENT_STATUS" == "Succeeded" ]]; then
              echo "Deployment completed successfully!"
              break
            elif [[ "$DEPLOYMENT_STATUS" == "Failed" || "$DEPLOYMENT_STATUS" == "Canceled" ]]; then
              echo "Deployment failed or was canceled!"
              # Get error details
              az deployment group show \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --name $DEPLOYMENT_NAME \
                --query "properties.error" -o json
              echo "Checking Activity Logs for more information..."
              # Check resource-specific activity logs
              az monitor activity-log list \
                --resource-group ${{ env.RESOURCE_GROUP }} \
                --caller "Microsoft.Resources" \
                --status "Failed" \
                --offset 1h \
                --max-events 10
              exit 1
            else
              echo "Deployment still in progress. Waiting $POLL_INTERVAL seconds..."
              sleep $POLL_INTERVAL
            fi
            
            CURRENT_TIME=$(date +%s)
          done
          
          # Check for timeout
          if [ $((CURRENT_TIME - START_TIME)) -ge $TIMEOUT_SECONDS ]; then
            echo "Deployment monitoring timed out after $((TIMEOUT_SECONDS / 60)) minutes!"
            echo "Deployment may still be in progress, but we'll proceed with output extraction."
          fi

          echo "Deployment finished. Getting outputs:"
          az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name $DEPLOYMENT_NAME \
            -o json > deployment-full.json

          # Extract and display outputs
          jq '.properties.outputs' deployment-full.json > bicep-outputs.json
          cat bicep-outputs.json
          
          # Check if deployment encountered any issues
          deployment_state=$(jq -r '.properties.provisioningState' deployment-full.json)
          echo "Deployment state: $deployment_state"
          
          if [[ "$deployment_state" != "Succeeded" ]]; then
            echo "Warning: Deployment did not complete successfully. Checking for errors..."
            # Display errors if available
            jq -r '.properties.error' deployment-full.json || echo "No error details available in deployment output"
            
            # Check activity logs for more information
            echo "Checking Azure activity logs for deployment errors..."
            az monitor.activity-log list --resource-group ${{ env.RESOURCE_GROUP }} --correlation-id $(jq -r '.properties.correlationId' deployment-full.json) --max-events 10

      - name: Get Storage, SQL Server, and SQL DB Names from Bicep Outputs
        id: get_resource_names
        run: |
          storage_account_name=$(jq -r '.storageAccountName.value' bicep-outputs.json)
          sql_server_name=$(jq -r '.sqlServerName.value' bicep-outputs.json)
          sql_db_name=$(jq -r '.sqlDbName.value' bicep-outputs.json)
          echo "storage_account_name=$storage_account_name" >> $GITHUB_OUTPUT
          echo "sql_server_name=$sql_server_name" >> $GITHUB_OUTPUT
          echo "sql_db_name=$sql_db_name" >> $GITHUB_OUTPUT      # No need to toggle AAD-only auth since we're using AAD authentication throughout

      - name: Get Application Insights Resource Name from Bicep Outputs
        id: get_appinsights_name
        run: |
          appinsights_name=$(jq -r '.appInsightsName.value' bicep-outputs.json)
          echo "appinsights_name=$appinsights_name" >> $GITHUB_OUTPUT

      # Add a verification step to check container app status
      - name: Check Container App Health
        run: |
          echo "Checking container app status..."
          
          # Check status for each container app
          for app in loan-processing-service customer-service web-ui; do
            echo "====== Checking status for container app '$app' ======"
            
            # Check if app exists and get status
            app_exists=$(az containerapp list --resource-group ${{ env.RESOURCE_GROUP }} --query "[?name=='$app'].id" -o tsv)
            
            if [ -n "$app_exists" ]; then
              echo "Container app '$app' exists. Getting status..."
              
              # Get basic status
              status=$(az containerapp show --name $app --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.provisioningState" -o tsv)
              echo "Provisioning state: $status"
                # Get latest revision status
              echo "Revision status:"
              revisions=$(az containerapp revision list --name $app --resource-group ${{ env.RESOURCE_GROUP }} --query "[].name" -o tsv)
              
              if [ -n "$revisions" ]; then
                echo "Revisions found:"
                az containerapp revision list --name $app --resource-group ${{ env.RESOURCE_GROUP }} --output table
                
                # Get container app logs
                echo "Container logs (last 20 lines):"
                az containerapp logs show --name $app --resource-group ${{ env.RESOURCE_GROUP }} --tail 20 || echo "Could not retrieve logs"
              else
                echo "No revisions found for container app '$app', skipping revision list and logs"
              fi
              
              # Check ingress configuration
              echo "Ingress configuration:"
              az containerapp show --name $app --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.configuration.ingress" -o json
              
              # If app isn't running properly, provide more information
              if [[ "$status" != "Succeeded" ]]; then
                echo "Warning: Container app is not in 'Succeeded' state. Additional diagnostics:"
                
                # Get container app environment status
                env_name=$(az containerapp show --name $app --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.managedEnvironmentId" -o tsv | awk -F'/' '{print $NF}')
                echo "Container app environment status ($env_name):"
                az containerapp env show --name $env_name --resource-group ${{ env.RESOURCE_GROUP }} --query "properties.provisioningState" -o tsv
                
                # Check if there are any activity log errors
                echo "Recent activity logs for this resource:"
                az monitor.activity-log list --resource-group ${{ env.RESOURCE_GROUP }} --resource-provider Microsoft.App --resource-type containerApps --resource-name $app --max-events 3
              fi
            else
              echo "Error: Container app '$app' does not exist after deployment!"
            fi
            echo ""
          done
          
          # Check container app environment status
          echo "Container app environment status:"
          az containerapp env list --resource-group ${{ env.RESOURCE_GROUP }} --output table

      - name: Get Managed Identity Principal ID
        id: get_managed_identity
        run: |
          # Check if identity exists
          existing_identity=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'id' -o tsv 2>/dev/null) || true
          
          if [ -z "$existing_identity" ]; then
            echo "Creating managed identity mortgageapp-identity"
            az identity create --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --location ${{ env.LOCATION }}
          else
            echo "Managed identity mortgageapp-identity already exists"
          fi
            # Get the principal ID
          principal_id=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'principalId' -o tsv)
          echo "principal_id=$principal_id" >> $GITHUB_OUTPUT

      - name: Get SQL Server FQDN
        id: get_sql_fqdn
        run: |
          # Use the SQL server name we already have from Bicep outputs instead of complex nested queries
          sql_fqdn=$(az sql server show --name ${{ steps.get_resource_names.outputs.sql_server_name }} --resource-group ${{ env.RESOURCE_GROUP }} --query fullyQualifiedDomainName -o tsv)
            # Add error handling
          if [ -z "$sql_fqdn" ]; then
            echo "Error: Could not retrieve SQL Server FQDN"
            exit 1
          fi
          
          echo "sql_fqdn=$sql_fqdn" >> $GITHUB_OUTPUT

      - name: Create Managed Identity User in SQL DB using Azure AD auth
        run: |
          # Enable verbose debugging and error handling
          set -e
          
          sql_server_name=${{ steps.get_resource_names.outputs.sql_server_name }}
          db_name=${{ steps.get_resource_names.outputs.sql_db_name }}
          principal_id=${{ steps.get_managed_identity.outputs.principal_id }}
          
          # Verify we have all required values
          if [ -z "$sql_server_name" ] || [ -z "$db_name" ] || [ -z "$principal_id" ]; then
            echo "Error: Missing required parameters for SQL user creation."
            [ -z "$sql_server_name" ] && echo "SQL server name is empty"
            [ -z "$db_name" ] && echo "Database name is empty"
            [ -z "$principal_id" ] && echo "Principal ID is empty"
            exit 1
          fi
          
          # Get the current runner's IP address
          echo "Getting current runner's public IP address..."
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "Current runner's public IP: $RUNNER_IP"
          
          # Add a firewall rule to allow access from the GitHub Actions runner
          echo "Adding SQL Server firewall rule for GitHub Actions runner..."
          az sql server firewall-rule create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --server $sql_server_name \
            --name "GithubActionsRunner-$GITHUB_RUN_ID" \
            --start-ip-address $RUNNER_IP \
            --end-ip-address $RUNNER_IP
          
          # Install the sqlcmd utility for AAD authentication
          echo "Installing sqlcmd utility..."
          curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
          curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
          sudo apt-get update
          sudo ACCEPT_EULA=Y apt-get install -y mssql-tools unixodbc-dev
          
          # Create SQL script for user creation with AD auth
          # This is simplified because the service principal already has SQL Server Contributor role
          cat > setup-aad-user.sql << EOF
          -- Create user for managed identity
          IF NOT EXISTS (SELECT * FROM sys.database_principals WHERE name = 'appidentity')
          BEGIN
              CREATE USER [appidentity] FROM EXTERNAL PROVIDER WITH OBJECT_ID = '$principal_id';
          END
          
          -- These statements are idempotent - adding a member to a role twice does not cause an error
          ALTER ROLE db_datareader ADD MEMBER [appidentity];
          ALTER ROLE db_datawriter ADD MEMBER [appidentity];
          EOF          # Execute commands using Azure AD authentication with the current signed-in user
          sql_fqdn=${{ steps.get_sql_fqdn.outputs.sql_fqdn }}
          echo "Executing SQL script against $sql_fqdn using AAD auth with access token..."
          
          # Get an access token for the SQL database
          echo "Obtaining Azure access token for SQL database..."
          token=$(az account get-access-token --resource https://database.windows.net/ --query accessToken -o tsv)
          
          if [ -z "$token" ]; then
            echo "Error: Could not obtain access token for SQL authentication"
            exit 1
          fi
            # Use access token for authentication instead of integrated auth
          echo "Running SQL commands with Azure AD token-based authentication"
          
          # Try with token-based auth
          echo "Attempting to execute SQL with token-based authentication..."
          if /opt/mssql-tools/bin/sqlcmd -S "$sql_fqdn" -d "$db_name" -P "$token" -G -I -C -i setup-aad-user.sql; then
            echo "SQL script executed successfully with token-based authentication."
          else
            echo "Token-based authentication failed. Trying alternative approach..."
            
            # Alternative approach: Use az sql commands directly
            echo "Using az sql db commands to create user and assign roles..."
            
            # Create a SQL script that uses the logged-in Azure admin to create our managed identity user
            cat > setup-aad-user-alt.sql << EOF
            -- Create user for managed identity
            IF NOT EXISTS (SELECT * FROM sys.database_principals WHERE name = 'appidentity')
            BEGIN
                CREATE USER [appidentity] FROM EXTERNAL PROVIDER WITH OBJECT_ID = '$principal_id';
            END
            
            -- These statements are idempotent - adding a member to a role twice does not cause an error
            ALTER ROLE db_datareader ADD MEMBER [appidentity];
            ALTER ROLE db_datawriter ADD MEMBER [appidentity];
            EOF
            
            # Execute T-SQL directly via az sql db query
            echo "Executing SQL with az sql db query..."
            az sql db query \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --server $sql_server_name \
              --name $db_name \
              --query-file setup-aad-user-alt.sql
            
            # Verify if the query was successful
            if [ $? -eq 0 ]; then
              echo "SQL user creation successful using az sql db query."
            else
              echo "Error: Failed to create SQL user using az sql db query."
              exit 1
            fi
          fi
            # Clean up: Remove the temporary firewall rule
          echo "Removing temporary SQL Server firewall rule..."
          az sql server firewall-rule delete \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --server $sql_server_name \
            --name "GithubActionsRunner-$GITHUB_RUN_ID" \
            --yes      

      - name: Assign Storage and SQL roles to system-assigned managed identities
        run: |
          # Get resource IDs
          storage_id=$(az storage account show --name ${{ steps.get_resource_names.outputs.storage_account_name }} --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query id -o tsv)
          sql_server_id=$(az sql server show --name ${{ steps.get_resource_names.outputs.sql_server_name }} --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query id -o tsv)
          sql_db_id=$(az sql db show --name ${{ steps.get_resource_names.outputs.sql_db_name }} --server ${{ steps.get_resource_names.outputs.sql_server_name }} --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query id -o tsv)

          # Assign Storage Blob Data Contributor to each container app identity
          for app in loan-processing-service customer-service web-ui; do
            principal_id=$(az containerapp show --name $app --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query identity.principalId -o tsv)
            
            # The az role assignment create command is idempotent by default
            # If the assignment already exists, it will not create a duplicate
            echo "Creating or ensuring role assignment for $app to Storage Blob Data Contributor"            az role assignment create --assignee $principal_id --role "Storage Blob Data Contributor" --scope $storage_id
          done

          # Container apps will use their system-assigned managed identities to access Azure SQL
          # This is handled by the Azure AD user we created earlier with the "appidentity" name
          # No additional SQL user creation needed here since we're using AAD authentication
          for app in loan-processing-service customer-service; do
            principal_id=$(az containerapp show --name $app --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query identity.principalId -o tsv)
            echo "Container app $app has principal ID: $principal_id - will use Azure AD authentication for SQL access"
          done

      - name: Create Application Insights Release Annotation (REST API)
        run: |
          app_id=${{ steps.get_appinsights_name.outputs.appinsights_name }}
          rg=${{ env.RESOURCE_GROUP }}
          subscription_id=$(az account show --query id -o tsv)
          annotation_id="release-${GITHUB_SHA}"
          # Creating timestamp in ISO8601 format (UTC)
          current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          body=$(jq -n \
            --arg id "$annotation_id" \
            --arg name "Release $GITHUB_SHA" \
            --arg desc "Release deployed from $GITHUB_REPOSITORY at commit $GITHUB_SHA (run $GITHUB_RUN_NUMBER)" \
            --arg sha "$GITHUB_SHA" \
            --arg run_id "$GITHUB_RUN_ID" \
            --arg workflow "$GITHUB_WORKFLOW" \
            --arg event_time "$current_time" \
            '{Id: $id, AnnotationName: $name, AnnotationDescription: $desc, Category: "Deployment", EventTime: $event_time, Tags: {sha: $sha, run_id: $run_id, workflow: $workflow, id: $id}}')
          az rest --method put \
            --uri "https://management.azure.com/subscriptions/${subscription_id}/resourceGroups/$rg/providers/microsoft.insights/components/$app_id/Annotations?api-version=2015-05-01" \
            --body "$body"

      - name: Copy JMeter file for Load Test
        run: |
          mkdir -p ${{ github.workspace }}/load-testing-artifacts
          cp ./load-testing/mortgage-demo.jmx ${{ github.workspace }}/load-testing-artifacts/mortgage-demo.jmx

      - name: Run Azure Load Test (smoke test)
        id: loadtest
        continue-on-error: true
        timeout-minutes: 3
        run: |
          # Get FQDNs from deployment outputs
          loan_fqdn=$(az deployment group show --resource-group ${{ env.RESOURCE_GROUP }} --name $(az deployment group list --resource-group ${{ env.RESOURCE_GROUP }} --query '[0].name' -o tsv) --query 'properties.outputs.loanProcessingFqdn.value' -o tsv)
          customer_fqdn=$(az deployment group show --resource-group ${{ env.RESOURCE_GROUP }} --name $(az deployment group list --resource-group ${{ env.RESOURCE_GROUP }} --query '[0].name' -o tsv) --query 'properties.outputs.customerServiceFqdn.value' -o tsv)

          # Create unique test names (with and without spaces) based on commit SHA
          test_id="mortgage-test-${GITHUB_SHA:0:8}"
          test_display_name="Smoke Test - ${GITHUB_SHA:0:8}"
          
          echo "Running Azure Load Test with display name: $test_display_name"
          echo "Test ID: $test_id"
          
          # First create/update the test definition
          test_exists=$(az load test show --name $test_id --resource-group ${{ env.RESOURCE_GROUP }} --load-test-resource mortgage-loadtest 2>/dev/null) || true
          
          if [ -z "$test_exists" ]; then
            echo "Creating new test definition: $test_id"
            az load test create \
              --test-id $test_id \
              --name $test_id \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --load-test-resource mortgage-loadtest \
              --test-plan "${{ github.workspace }}/load-testing-artifacts/mortgage-demo.jmx" \
              --description "Smoke test for mortgage application" \
              --display-name "$test_display_name" \
              --env LOAN_API_HOST="$loan_fqdn" CUSTOMER_API_HOST="$customer_fqdn"
          else
            echo "Test already exists. Updating test plan."
            az load test update \
              --test-id $test_id \
              --name $test_id \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --load-test-resource mortgage-loadtest \
              --test-plan "${{ github.workspace }}/load-testing-artifacts/mortgage-demo.jmx" \
              --display-name "$test_display_name" \
              --env LOAN_API_HOST="$loan_fqdn" CUSTOMER_API_HOST="$customer_fqdn"
          fi
            # Now run the test
          echo "Starting test run for: $test_id"
          az load test-run start \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --load-test-resource mortgage-loadtest \
            --test-id $test_id \
            --display-name "$test_display_name"

      - name: Azure Logout
        run: az logout
