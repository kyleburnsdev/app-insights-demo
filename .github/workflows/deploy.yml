name: Deploy Mortgage Demo to Azure

on:
  workflow_dispatch:
  push:
    branches:
      - main

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    env:
      AZURE_SQL_ADMIN_USERNAME: ${{ secrets.AZURE_SQL_ADMIN_USERNAME }}
      AZURE_SQL_ADMIN_PASSWORD: ${{ secrets.AZURE_SQL_ADMIN_PASSWORD }}
      AZURE_CONTAINER_REGISTRY: ${{ secrets.AZURE_CONTAINER_REGISTRY }}
      AZURE_CONTAINER_REGISTRY_USERNAME: ${{ secrets.AZURE_CONTAINER_REGISTRY_USERNAME }}
      AZURE_CONTAINER_REGISTRY_PASSWORD: ${{ secrets.AZURE_CONTAINER_REGISTRY_PASSWORD }}
      AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
      RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP }}
      LOCATION: ${{ vars.AZURE_LOCATION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20.x'

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v2
        with:
          login-server: ${{ env.AZURE_CONTAINER_REGISTRY }}
          username: ${{ env.AZURE_CONTAINER_REGISTRY_USERNAME }}
          password: ${{ env.AZURE_CONTAINER_REGISTRY_PASSWORD }}

      - name: Build and push Loan Processing Service (.NET)
        run: |
          cd loan-processing-service
          dotnet publish -c Release -o out
          docker build -t ${{ env.AZURE_CONTAINER_REGISTRY }}/loan-processing-service:${{ github.sha }} .
          docker push ${{ env.AZURE_CONTAINER_REGISTRY }}/loan-processing-service:${{ github.sha }}

      - name: Build and push Customer Service (Java)
        run: |
          cd customer-service
          ./mvnw package -DskipTests || mvn package -DskipTests
          docker build -t ${{ env.AZURE_CONTAINER_REGISTRY }}/customer-service:${{ github.sha }} .
          docker push ${{ env.AZURE_CONTAINER_REGISTRY }}/customer-service:${{ github.sha }}

      - name: Build and push Web UI (React)
        run: |
          cd web-ui
          npm install
          npm run build
          docker build -t ${{ env.AZURE_CONTAINER_REGISTRY }}/web-ui:${{ github.sha }} .
          docker push ${{ env.AZURE_CONTAINER_REGISTRY }}/web-ui:${{ github.sha }}

      - name: Deploy infrastructure and container apps (Bicep)
        id: deploy_bicep
        run: |
          DEPLOYMENT_NAME=mortgage-deployment-${{ github.sha }}
          az deployment group create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --template-file infra/main.bicep \
            --parameters \
              sqlAdminUsername=${{ env.AZURE_SQL_ADMIN_USERNAME }} \
              sqlAdminPassword=${{ env.AZURE_SQL_ADMIN_PASSWORD }} \
              loanProcessingImage=${{ env.AZURE_CONTAINER_REGISTRY }}/loan-processing-service:${{ github.sha }} \
              customerServiceImage=${{ env.AZURE_CONTAINER_REGISTRY }}/customer-service:${{ github.sha }} \
              webUiImage=${{ env.AZURE_CONTAINER_REGISTRY }}/web-ui:${{ github.sha }} \
              registryUsername=${{ env.AZURE_CONTAINER_REGISTRY_USERNAME }} \
              registryPassword=${{ env.AZURE_CONTAINER_REGISTRY_PASSWORD }} \
              registryServer=${{ env.AZURE_CONTAINER_REGISTRY }} \
            --name $DEPLOYMENT_NAME

          echo "Deployment finished. Getting outputs:"
          az deployment group show \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --name $DEPLOYMENT_NAME \
            -o json > deployment-full.json

          cat deployment-full.json
          jq '.properties.outputs' deployment-full.json > bicep-outputs.json
          cat bicep-outputs.json

      - name: Get Storage, SQL Server, and SQL DB Names from Bicep Outputs
        id: get_resource_names
        run: |
          storage_account_name=$(jq -r '.storageAccountName.value' bicep-outputs.json)
          sql_server_name=$(jq -r '.sqlServerName.value' bicep-outputs.json)
          sql_db_name=$(jq -r '.sqlDbName.value' bicep-outputs.json)
          echo "storage_account_name=$storage_account_name" >> $GITHUB_OUTPUT
          echo "sql_server_name=$sql_server_name" >> $GITHUB_OUTPUT
          echo "sql_db_name=$sql_db_name" >> $GITHUB_OUTPUT

      - name: Get Application Insights Resource Name from Bicep Outputs
        id: get_appinsights_name
        run: |
          appinsights_name=$(jq -r '.appInsightsName.value' bicep-outputs.json)
          echo "appinsights_name=$appinsights_name" >> $GITHUB_OUTPUT

      - name: Get Managed Identity Principal ID
        id: get_managed_identity
        run: |
          # Check if identity exists
          existing_identity=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'id' -o tsv 2>/dev/null) || true
          
          if [ -z "$existing_identity" ]; then
            echo "Creating managed identity mortgageapp-identity"
            az identity create --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --location ${{ env.LOCATION }}
          else
            echo "Managed identity mortgageapp-identity already exists"
          fi
          
          # Get the principal ID
          principal_id=$(az identity show --name mortgageapp-identity --resource-group ${{ env.RESOURCE_GROUP }} --query 'principalId' -o tsv)
          echo "principal_id=$principal_id" >> $GITHUB_OUTPUT

      - name: Get SQL Server FQDN
        id: get_sql_fqdn
        run: |
          sql_fqdn=$(az sql server show --name $(az deployment group show --resource-group ${{ env.RESOURCE_GROUP }} --name $(az deployment group list --resource-group ${{ env.RESOURCE_GROUP }} --query '[0].name' -o tsv) --query 'properties.outputs.sqlServerName.value' -o tsv) --resource-group ${{ env.RESOURCE_GROUP }} --query fullyQualifiedDomainName -o tsv)
          echo "sql_fqdn=$sql_fqdn" >> $GITHUB_OUTPUT
          
      - name: Create Managed Identity User in SQL DB
        env:
          AZURE_SQL_ADMIN_USERNAME: ${{ env.AZURE_SQL_ADMIN_USERNAME }}
          AZURE_SQL_ADMIN_PASSWORD: ${{ env.AZURE_SQL_ADMIN_PASSWORD }}
        run: |
          sql_server_name=${{ steps.get_resource_names.outputs.sql_server_name }}
          db_name=${{ steps.get_resource_names.outputs.sql_db_name }}
          principal_id=${{ steps.get_managed_identity.outputs.principal_id }}
            # Create an idempotent SQL script that checks if user exists before creating
          cat > setup-user.sql << EOF
          IF NOT EXISTS (SELECT * FROM sys.database_principals WHERE name = 'appidentity')
          BEGIN
              CREATE USER [appidentity] FROM EXTERNAL PROVIDER;
          END
          
          -- These statements are idempotent - adding a member to a role twice does not cause an error
          ALTER ROLE db_datareader ADD MEMBER [appidentity];
          ALTER ROLE db_datawriter ADD MEMBER [appidentity];
          EOF          # Get the current runner's IP address
          echo "Getting current runner's public IP address..."
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "Current runner's public IP: $RUNNER_IP"
          
          # Add a firewall rule to allow access from the GitHub Actions runner
          echo "Adding SQL Server firewall rule for GitHub Actions runner..."
          az sql server firewall-rule create \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --server $sql_server_name \
            --name "GithubActionsRunner-$GITHUB_RUN_ID" \
            --start-ip-address $RUNNER_IP \
            --end-ip-address $RUNNER_IP
          
          echo "Starting sqlcmd installation while firewall rule propagates..."
          
          # Install the sqlcmd utility
          echo "Installing sqlcmd utility..."
          curl https://packages.microsoft.com/keys/microsoft.asc | sudo apt-key add -
          curl https://packages.microsoft.com/config/ubuntu/20.04/prod.list | sudo tee /etc/apt/sources.list.d/msprod.list
          sudo apt-get update
          sudo ACCEPT_EULA=Y apt-get install -y mssql-tools unixodbc-dev
          
          # Give some additional time for the firewall rule to fully propagate if needed
          echo "Waiting a moment to ensure firewall rule has propagated..."
          sleep 10
            
          # Execute the SQL script using sqlcmd
          sql_fqdn=${{ steps.get_sql_fqdn.outputs.sql_fqdn }}
          echo "Executing SQL script against $sql_fqdn..."
          /opt/mssql-tools/bin/sqlcmd -S "$sql_fqdn" -d "$db_name" -U "$AZURE_SQL_ADMIN_USERNAME" -P "$AZURE_SQL_ADMIN_PASSWORD" -i setup-user.sql
          
          # Clean up: Remove the temporary firewall rule
          echo "Removing temporary SQL Server firewall rule..."
          az sql server firewall-rule delete \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --server $sql_server_name \
            --name "GithubActionsRunner-$GITHUB_RUN_ID" \
            --yes

      - name: Create Blob Storage Container
        run: |
          storage_account=${{ steps.get_resource_names.outputs.storage_account_name }}
          echo "Creating blob container if it doesn't exist..."
          echo "Using storage account: $storage_account in resource group: ${{ env.RESOURCE_GROUP }}"
          
          # First, check if storage account exists
          if ! az storage account show --name $storage_account --resource-group ${{ env.RESOURCE_GROUP }} &>/dev/null; then
            echo "Error: Storage account $storage_account not found in resource group ${{ env.RESOURCE_GROUP }}"
            exit 1
          fi
            # Get the storage account key for authentication
          echo "Getting storage account key..."
          storage_key=$(az storage account keys list --account-name $storage_account --resource-group ${{ env.RESOURCE_GROUP }} --query "[0].value" -o tsv)
          
          if [ -z "$storage_key" ]; then
            echo "Error: Could not retrieve storage account key"
            exit 1
          fi
            # Check if container exists first (idempotency)
          echo "Checking if container exists..."
          container_exists=$(az storage container exists \
            --account-name $storage_account \
            --name "mortgage-data" \
            --account-key "$storage_key" \
            --query exists -o tsv)
            
          if [ "$container_exists" = "true" ]; then
            echo "Container 'mortgage-data' already exists. Skipping creation."
          else
            echo "Container 'mortgage-data' does not exist. Creating now..."
            az storage container create \
              --account-name $storage_account \
              --name "mortgage-data" \
              --account-key "$storage_key"
            echo "Container created successfully."
          fi

      - name: Assign Storage and SQL roles to system-assigned managed identities
        run: |
          # Get resource IDs
          storage_id=$(az storage account show --name ${{ steps.get_resource_names.outputs.storage_account_name }} --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query id -o tsv)
          sql_server_id=$(az sql server show --name ${{ steps.get_resource_names.outputs.sql_server_name }} --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query id -o tsv)
          sql_db_id=$(az sql db show --name ${{ steps.get_resource_names.outputs.sql_db_name }} --server ${{ steps.get_resource_names.outputs.sql_server_name }} --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query id -o tsv)

          # Assign Storage Blob Data Contributor to each container app identity
          for app in loan-processing-service customer-service web-ui; do
            principal_id=$(az containerapp show --name $app --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query identity.principalId -o tsv)
            
            # The az role assignment create command is idempotent by default
            # If the assignment already exists, it will not create a duplicate
            echo "Creating or ensuring role assignment for $app to Storage Blob Data Contributor"
            az role assignment create --assignee $principal_id --role "Storage Blob Data Contributor" --scope $storage_id
          done

          # Assign SQL roles (example: db_datareader, db_datawriter) to loan-processing-service and customer-service
          for app in loan-processing-service customer-service; do
            principal_id=$(az containerapp show --name $app --resource-group ${{ vars.AZURE_RESOURCE_GROUP }} --query identity.principalId -o tsv)
            # This step assumes you have a script or process to create the contained user in SQL DB for the principal_id
            echo "Assign SQL roles for $app (principal_id: $principal_id) - see documentation for contained user creation."
          done

      - name: Create Application Insights Release Annotation
        run: |
          # Create a unique annotation ID based on the commit SHA to make it idempotent
          annotation_id="release-${GITHUB_SHA}"
          
          # Check if an annotation with this ID exists (using tags)
          existing_annotation=$(az monitor app-insights annotation list \
            --app ${{ steps.get_appinsights_name.outputs.appinsights_name }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --query "[?contains(tags.sha, '${GITHUB_SHA}')].id" -o tsv)
            
          if [ -z "$existing_annotation" ]; then
            echo "Creating new release annotation for commit ${GITHUB_SHA}"
            az monitor app-insights annotation create \
              --app ${{ steps.get_appinsights_name.outputs.appinsights_name }} \
              --resource-group ${{ env.RESOURCE_GROUP }} \
              --annotation-name "Release ${GITHUB_SHA}" \
              --annotation-description "Release deployed from $GITHUB_REPOSITORY at commit $GITHUB_SHA (run $GITHUB_RUN_NUMBER)" \
              --tags "sha=${GITHUB_SHA}" "run_id=${GITHUB_RUN_ID}" "workflow=${GITHUB_WORKFLOW}" "id=${annotation_id}"
          else
            echo "Release annotation for commit ${GITHUB_SHA} already exists"
          fi

      - name: Copy JMeter file for Load Test
        run: |
          mkdir -p ${{ github.workspace }}/load-testing-artifacts
          cp ./load-testing/mortgage-demo.jmx ${{ github.workspace }}/load-testing-artifacts/mortgage-demo.jmx

      - name: Run Azure Load Test (smoke test)
        id: loadtest
        run: |
          # Get FQDNs from deployment outputs
          loan_fqdn=$(az deployment group show --resource-group ${{ env.RESOURCE_GROUP }} --name $(az deployment group list --resource-group ${{ env.RESOURCE_GROUP }} --query '[0].name' -o tsv) --query 'properties.outputs.loanProcessingFqdn.value' -o tsv)
          customer_fqdn=$(az deployment group show --resource-group ${{ env.RESOURCE_GROUP }} --name $(az deployment group list --resource-group ${{ env.RESOURCE_GROUP }} --query '[0].name' -o tsv) --query 'properties.outputs.customerServiceFqdn.value' -o tsv)

          # Create a unique test run name based on commit SHA
          test_name="Smoke Test - ${GITHUB_SHA}"
          
          echo "Running Azure Load Test with display name: $test_name"
          # Run Azure Load Test with JMeter file and host variables
          # Note: Azure Load Testing naturally supports idempotency as each run creates a new test run
          az load test-run create \
            --load-test-resource mortgage-loadtest \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --test-plan ${{ github.workspace }}/load-testing-artifacts/mortgage-demo.jmx \
            --env-variables LOAN_API_HOST=$loan_fqdn CUSTOMER_API_HOST=$customer_fqdn \
            --display-name "$test_name"

      - name: Azure Logout
        run: az logout
